# Extended Joust - Complete Specification

## Part 4: Communication Protocol

---

## üîå Socket.IO Events

### Client ‚Üí Server Events

#### `player:join`

**When**: Player enters name and clicks "Join Game"

**Payload**:

```typescript
{
  playerId: string,    // UUID generated client-side
  name: string         // Player's chosen name (1-20 chars)
}
```

**Server Response**: `player:joined` event

---

#### `player:move`

**When**: Accelerometer data available (throttled to 10Hz)

**Payload**:

```typescript
{
  playerId: string,
  x: number,           // -10 to +10
  y: number,           // -10 to +10
  z: number,           // -10 to +10
  timestamp: number,   // Date.now()
  deviceType: 'phone'  // Optional: 'phone' | 'joycon' | 'custom'
}
```

**Throttling**: Send max 10 times per second (every 100ms)

**Implementation**:

```typescript
let lastSendTime = 0;
const SEND_INTERVAL = 100; // 100ms = 10Hz

function sendMovementData(data: { x: number; y: number; z: number }) {
  const now = Date.now();
  if (now - lastSendTime < SEND_INTERVAL) return;

  lastSendTime = now;
  socket.emit("player:move", {
    playerId: myPlayerId,
    ...data,
    timestamp: now,
    deviceType: "phone",
  });
}
```

---

#### `player:reconnect`

**When**: Player disconnects and attempts to rejoin within 10s grace period

**Payload**:

```typescript
{
  token: string,       // Session token from localStorage
  socketId: string     // New socket ID from reconnection
}
```

**Server Response**: `player:reconnected` event

---

#### `ping`

**When**: Every 5 seconds to maintain connection

**Payload**: None

**Server Response**: `pong` event

---

### Server ‚Üí Client Events

#### `player:joined`

**When**: Response to successful `player:join` request

**Payload**:

```typescript
{
  success: boolean,
  playerId: string,
  playerNumber: number,     // 1-20 (assigned sequentially)
  socketId: string,
  sessionToken: string      // Store in localStorage for reconnection
}
```

**Client Action**:

```typescript
socket.on("player:joined", (data) => {
  if (data.success) {
    localStorage.setItem("sessionToken", data.sessionToken);
    localStorage.setItem("playerId", data.playerId);
    localStorage.setItem("playerNumber", data.playerNumber.toString());
    navigate("/player");
  }
});
```

---

#### `player:reconnected`

**When**: Response to successful `player:reconnect` request

**Payload**:

```typescript
{
  success: boolean,
  playerId: string,
  player: {
    id: string,
    name: string,
    number: number,
    role: string,          // Role class name (e.g., "Vampire")
    isAlive: boolean,
    points: number,
    totalPoints: number
  }
}
```

**Client Action**:

```typescript
socket.on("player:reconnected", (data) => {
  if (data.success) {
    setConnected(true);
    updatePlayerState(data.player);
  }
});
```

---

#### `game:tick`

**When**: Every 100ms during active game (10 times per second)

**Payload**:

```typescript
{
  gameTime: number; // Milliseconds since round start
}
```

**Usage**: Update timers, check status effect expirations

---

#### `player:death`

**When**: Any player dies

**Payload**:

```typescript
{
  victimId: string,
  victimName: string,
  victimNumber: number,
  gameTime: number
}
```

**Client Actions**:

```typescript
socket.on("player:death", ({ victimId, victimNumber }) => {
  // If victim is me
  if (victimId === myPlayerId) {
    audioManager.play("death");
    showDeathScreen();
  }

  // If victim is my target (Beast Hunter, Assassin)
  if (victimNumber === myTargetNumber) {
    showTargetEliminatedNotification();
  }

  // Dashboard: Update player card to dead state
  updatePlayerCard(victimId, { isAlive: false });
});
```

---

#### `round:start`

**When**: Round beginning (after role assignments)

**Payload**:

```typescript
{
  roundNumber: number,
  totalRounds: number,
  gameTime: number
}
```

**Client Actions**:

```typescript
socket.on("round:start", ({ roundNumber, totalRounds }) => {
  // Player View: Show "Round X/Y" briefly
  showRoundStartNotification(roundNumber, totalRounds);

  // Dashboard: Start countdown "3... 2... 1... GO!"
  if (isDashboard) {
    playCountdown();
  }
});
```

---

#### `round:end`

**When**: Round conclusion (0-1 players remaining)

**Payload**:

```typescript
{
  roundNumber: number,
  scores: Array<{
    playerId: string,
    playerName: string,
    playerNumber: number,
    score: number,          // Points this round
    rank: number,           // 1-20
    status: string          // "Winner", "Eliminated", etc.
  }>,
  gameTime: number
}
```

**Client Actions**:

```typescript
socket.on("round:end", ({ scores }) => {
  // Dashboard: Show leaderboard screen
  showLeaderboard(scores);

  // Player View: Show personal score
  const myScore = scores.find((s) => s.playerId === myPlayerId);
  showRoundSummary(myScore);
});
```

---

#### `game:end`

**When**: Game finished (after all rounds)

**Payload**:

```typescript
{
  winner: {
    id: string,
    name: string,
    number: number
  } | null,
  scores: Array<{
    playerId: string,
    playerName: string,
    playerNumber: number,
    totalPoints: number,    // Cumulative across all rounds
    rank: number,
    status: string
  }>,
  totalRounds: number
}
```

**Client Actions**:

```typescript
socket.on("game:end", ({ winner, scores }) => {
  // Dashboard: Show final leaderboard + winner announcement
  audioManager.play("victory");
  audioManager.speak(`${winner.name} is the champion!`);
  showFinalLeaderboard(scores);

  // Player View: Show final placement
  const myFinalScore = scores.find((s) => s.playerId === myPlayerId);
  showGameSummary(myFinalScore);
});
```

---

#### `vampire:bloodlust`

**When**: Vampire bloodlust state changes

**Payload**:

```typescript
{
  vampireId: string,
  vampireName: string,
  vampireNumber: number,
  active: boolean      // true = started, false = ended
}
```

**Client Actions**:

```typescript
socket.on("vampire:bloodlust", ({ vampireId, active }) => {
  // If vampire is me
  if (vampireId === myPlayerId) {
    if (active) {
      // Show bloodlust UI + play heartbeat sound
      setBloodlustActive(true);
      audioManager.loop("heartbeat", { volume: 0.6 });
    } else {
      // Hide bloodlust UI + stop heartbeat
      setBloodlustActive(false);
      audioManager.stop("heartbeat");
    }
  }

  // Dashboard: Update vampire's card with üßõ icon
  updatePlayerCard(vampireId, { statusIcon: active ? "üßõ" : null });
});
```

---

#### `role:assigned`

**When**: Game starts, each player receives their role privately

**Payload**:

```typescript
{
  role: string,              // e.g., "Vampire", "Beast Hunter"
  displayName: string,       // e.g., "Vampire"
  description: string,       // "Enter bloodlust every 30s. Kill or be killed!"
  targetNumber?: number,     // For targeted roles (Beast Hunter ‚Üí Beast)
  targetName?: string
}
```

**Client Actions**:

```typescript
socket.on("role:assigned", ({ role, description, targetNumber }) => {
  // Play intro sound
  audioManager.play("role-reveal", { volume: 0.7 });

  // Wait 500ms for intro sound to finish
  setTimeout(() => {
    // Speak role assignment via TTS
    let speech = `You are the ${role}. ${description}`;

    if (targetNumber) {
      speech += ` Your target is Player number ${targetNumber}.`;
    }

    audioManager.speak(speech);
  }, 500);

  // Store role info
  setMyRole(role);
  setMyTarget(targetNumber);
});
```

---

#### `pong`

**When**: Response to `ping` heartbeat

**Payload**: None

**Client Action**: Update last ping timestamp

---

#### `error`

**When**: Error notifications from server

**Payload**:

```typescript
{
  message: string,
  code: string          // e.g., 'INVALID_MOVEMENT_DATA', 'GAME_FULL'
}
```

**Client Actions**:

```typescript
socket.on("error", ({ message, code }) => {
  switch (code) {
    case "GAME_FULL":
      showError("Game is full. Please wait for next game.");
      break;
    case "GAME_ALREADY_STARTED":
      showError("Game already in progress. Wait for next round.");
      break;
    case "INVALID_SESSION_TOKEN":
      localStorage.removeItem("sessionToken");
      navigate("/join");
      break;
    default:
      showError(message);
  }
});
```

---

## üì° HTTP REST API Endpoints

### GET `/api/game/modes`

**Purpose**: List available game modes

**Auth**: None

**Response**:

```typescript
{
  success: boolean,
  modes: Array<{
    key: string,           // 'classic', 'role-based', etc.
    name: string,
    description: string,
    minPlayers: number,
    maxPlayers: number,
    useRoles: boolean,
    multiRound: boolean,
    roundCount: number,
    roleTheme?: string     // For role-based modes
  }>
}
```

**Example**:

```json
{
  "success": true,
  "modes": [
    {
      "key": "classic",
      "name": "Classic",
      "description": "Pure movement survival. Last player standing wins!",
      "minPlayers": 2,
      "maxPlayers": 20,
      "useRoles": false,
      "multiRound": false,
      "roundCount": 1
    },
    {
      "key": "role-based",
      "name": "Role Based",
      "description": "Unique abilities. Earn points across multiple rounds!",
      "minPlayers": 2,
      "maxPlayers": 20,
      "useRoles": true,
      "multiRound": true,
      "roundCount": 3,
      "roleTheme": "standard"
    }
  ]
}
```

---

### POST `/api/game/create`

**Purpose**: Create game lobby (dashboard only)

**Auth**: None (future: dashboard auth)

**Request**:

```typescript
{
  mode: string,          // 'classic' | 'role-based'
  theme?: string         // For role-based: 'standard' | 'halloween' | 'mafia'
}
```

**Response**:

```typescript
{
  success: boolean,
  gameId: string,
  mode: {
    name: string,
    description: string,
    minPlayers: number,
    maxPlayers: number
  }
}
```

---

### POST `/api/game/start`

**Purpose**: Start game with connected players (dashboard only)

**Auth**: None (future: dashboard auth)

**Request**:

```typescript
{
  players: Array<{
    id: string;
    name: string;
    socketId: string;
  }>;
}
```

**Response**:

```typescript
{
  success: boolean,
  gameState: {
    gameTime: number,
    state: 'active',
    currentRound: number,
    mode: string,
    playerCount: number,
    alivePlayers: number,
    players: Array<{...}>
  }
}
```

---

### GET `/api/game/state`

**Purpose**: Get current game state (for reconnection, debugging)

**Auth**: None

**Response**:

```typescript
{
  success: boolean,
  state: {
    gameTime: number,
    state: 'waiting' | 'active' | 'round-ended' | 'finished',
    currentRound: number,
    mode: string,
    playerCount: number,
    alivePlayers: number,
    players: Array<{
      id: string,
      name: string,
      number: number,
      role: string,
      isAlive: boolean,
      points: number,
      totalPoints: number
    }>
  }
}
```

---

### POST `/api/game/stop`

**Purpose**: Emergency stop (dashboard only)

**Auth**: None (future: dashboard auth)

**Request**: None

**Response**:

```typescript
{
  success: boolean,
  message: string
}
```

---

### GET `/api/player/:playerId/role`

**Purpose**: Get player's assigned role

**Auth**: Player must own this ID (future: validate)

**Response**:

```typescript
{
  success: boolean,
  role: {
    name: string,
    displayName: string,
    description: string,
    difficulty: string
  },
  player: {
    id: string,
    name: string,
    number: number,
    isAlive: boolean,
    points: number
  }
}
```

---

### GET `/api/player/:playerId/state`

**Purpose**: Get player's current state (health, effects, etc.)

**Auth**: Player must own this ID (future: validate)

**Response**:

```typescript
{
  success: boolean,
  player: {
    id: string,
    name: string,
    number: number,
    role: string,
    isAlive: boolean,
    points: number,
    totalPoints: number,
    toughness: number,
    statusEffects: Array<{
      type: string,
      priority: number,
      timeLeft: number | null
    }>
  }
}
```

---

### POST `/api/player/reconnect`

**Purpose**: Reconnect with session token (alternative to Socket.IO reconnect)

**Auth**: Valid session token

**Request**:

```typescript
{
  token: string,
  socketId: string
}
```

**Response**:

```typescript
{
  success: boolean,
  playerId: string,
  player: {
    id: string,
    name: string,
    number: number,
    role: string,
    isAlive: boolean,
    points: number
  }
}
```

---

## üîÑ Auto-Reconnection Logic

```typescript
// socket.ts
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;

socket.on("disconnect", (reason) => {
  setConnected(false);
  console.log("Disconnected:", reason);

  const sessionToken = localStorage.getItem("sessionToken");
  if (!sessionToken) return;

  // Try to reconnect every 2s for 10s (5 attempts)
  const reconnectInterval = setInterval(() => {
    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
      clearInterval(reconnectInterval);
      showError("Could not reconnect. Please rejoin.");
      return;
    }

    reconnectAttempts++;
    console.log(`Reconnect attempt ${reconnectAttempts}...`);

    socket.emit("player:reconnect", {
      token: sessionToken,
      socketId: socket.id,
    });
  }, 2000);
});

socket.on("player:reconnected", (data) => {
  reconnectAttempts = 0;

  if (data.success) {
    setConnected(true);
    console.log("Reconnected successfully!");
    updatePlayerState(data.player);
  } else {
    showError("Reconnection failed. Please rejoin.");
    localStorage.removeItem("sessionToken");
    navigate("/join");
  }
});
```

---

## üåê API Base URL Configuration

```typescript
// config.ts
export const API_BASE_URL =
  import.meta.env.VITE_API_BASE_URL || "http://localhost:3000";

// Usage in api.ts
const response = await fetch(`${API_BASE_URL}/api/game/modes`);

// Usage in socket.ts
const socket = io(API_BASE_URL, {
  transports: ["websocket", "polling"],
  reconnection: true,
  reconnectionDelay: 1000,
  reconnectionAttempts: 5,
});
```

**Environment Variables** (`.env` file):

```bash
# Development
VITE_API_BASE_URL=http://localhost:3000

# Production (same machine)
VITE_API_BASE_URL=http://localhost:3000

# Production (separate machines)
VITE_API_BASE_URL=http://192.168.1.100:3000
```

---

This specification continues in **Part 5: Project Structure** ‚Üí
