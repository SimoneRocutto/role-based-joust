# Extended Joust - Complete Specification

## Part 2: Audio System

---

## ğŸµ Audio Architecture

Three independent audio layers running simultaneously:

1. **Background Music** - Continuous ambient/tension music (Dashboard + Players)
2. **TTS Announcements** - Text-to-speech for events (Dashboard only)
3. **Sound Effects** - Event-triggered sounds (Players + Dashboard)

---

## ğŸ¼ Audio Layers

### Layer 1: Background Music

**Purpose**: Create atmosphere and tension escalation

**Files**:

- `lobby-music.mp3` - Calm, waiting music
- `tension-medium.mp3` - Active gameplay, standard tension
- `tension-high.mp3` - High tension, 3 or fewer players remaining

**Playback**:

- Continuous loop
- Crossfade between tracks (1-2s fade)
- Volume: 40% during gameplay

**Transitions**:

| Game State              | Music Track          | Trigger                             |
| ----------------------- | -------------------- | ----------------------------------- |
| Lobby/Waiting           | `lobby-music.mp3`    | Players joining, before game starts |
| Round Active (4+ alive) | `tension-medium.mp3` | Round starts                        |
| Round Active (â‰¤3 alive) | `tension-high.mp3`   | 4th player dies                     |
| Round End               | `victory.mp3`        | Round/game ends                     |
| Between Rounds          | `lobby-music.mp3`    | Leaderboard screen                  |

**Code Example**:

```typescript
// In Dashboard component
useEffect(() => {
  const aliveCount = players.filter((p) => p.isAlive).length;

  if (gameState === "waiting") {
    audioManager.playMusic("lobby-music", { loop: true, volume: 0.4 });
  } else if (gameState === "active") {
    if (aliveCount <= 3) {
      audioManager.playMusic("tension-high", { loop: true, volume: 0.5 });
    } else {
      audioManager.playMusic("tension-medium", { loop: true, volume: 0.4 });
    }
  } else if (gameState === "round-ended") {
    audioManager.playMusic("victory", { loop: false, volume: 0.6 });
  }
}, [gameState, aliveCount]);
```

---

### Layer 2: TTS Announcements (Dashboard Only)

**Purpose**: Provide live commentary for spectators

**Behavior**:

- Plays on dashboard speakers (not player earbuds)
- **Audio ducking**: Background music lowers to 20% volume during speech
- Restores music volume after speech ends
- Uses Web Speech API: `window.speechSynthesis`

**Events That Trigger TTS**:

| Event        | TTS Text                             | Priority |
| ------------ | ------------------------------------ | -------- |
| Player Death | "Player {number} eliminated!"        | High     |
| Round Start  | "Round {N} starting in 3, 2, 1, GO!" | Critical |
| Round End    | "{PlayerName} wins round {N}!"       | High     |
| Game End     | "{PlayerName} is the champion!"      | Critical |

**Events That Do NOT Trigger TTS**:

- âŒ Player count milestones ("3 players remaining")
- âŒ Bloodlust events (hidden information)
- âŒ Status effect changes
- âŒ Damage taken

**Code Example**:

```typescript
// audioManager.ts
class AudioManager {
  private musicVolume = 0.4;
  private ttsQueue: string[] = [];
  private isSpeaking = false;

  speak(text: string) {
    if (!window.speechSynthesis) return;

    // Duck background music
    this.music?.volume(0.2); // Lower to 20%

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.rate = 1.1; // Slightly faster
    utterance.pitch = 1.0;
    utterance.volume = 1.0;

    utterance.onend = () => {
      // Restore music volume
      this.music?.volume(this.musicVolume);
      this.isSpeaking = false;
      this.processQueue();
    };

    this.isSpeaking = true;
    window.speechSynthesis.speak(utterance);
  }

  private processQueue() {
    if (this.ttsQueue.length > 0 && !this.isSpeaking) {
      const next = this.ttsQueue.shift();
      if (next) this.speak(next);
    }
  }
}

// Usage in Dashboard
socket.on("player:death", ({ victimNumber }) => {
  audioManager.speak(`Player ${victimNumber} eliminated!`);
});
```

---

### Layer 3: Sound Effects

**Purpose**: Immediate feedback for specific events

**Playback**:

- Short clips (< 2s)
- Can overlap (use Howler.js sprite pooling)
- Play on top of music without ducking

#### Dashboard Sound Effects

| File            | Trigger                                              | Volume |
| --------------- | ---------------------------------------------------- | ------ |
| `death.mp3`     | Any player dies                                      | 0.5    |
| `victory.mp3`   | Round/game ends                                      | 0.6    |
| `bloodlust.mp3` | Vampire bloodlust starts (visual-only cue, no sound) | N/A    |
| `wolf-howl.mp3` | Full moon event (Halloween mode)                     | 0.4    |

#### Player Sound Effects (Private, via Earbud)

| File                       | Trigger                        | Volume | Notes                                      |
| -------------------------- | ------------------------------ | ------ | ------------------------------------------ |
| `role-reveal.mp3`          | Role assignment                | 0.7    | Plays before TTS                           |
| `damage.mp3`               | **Every damage tick**          | 0.3    | Short "oof" or thud                        |
| `low-health-heartbeat.mp3` | Health < 30%                   | 0.4    | Looping heartbeat, stops when health > 30% |
| `target-update.mp3`        | Target changes (Assassin role) | 0.6    | Future feature                             |

**Removed Sounds**:

- ~~`too-much-movement.mp3`~~ - Not needed (damage sound is enough)

**Code Example**:

```typescript
// Player View - damage feedback
socket.on("game:tick", ({ gameTime }) => {
  const myPlayer = players.find((p) => p.id === myPlayerId);

  // Play damage sound on every tick where we took damage
  if (myPlayer.lastDamage && myPlayer.lastDamage.gameTime === gameTime) {
    audioManager.play("damage", { volume: 0.3 });
  }

  // Start/stop heartbeat based on health
  const healthPercent = 1 - myPlayer.accumulatedDamage / 100;
  if (healthPercent < 0.3 && !audioManager.isPlaying("heartbeat")) {
    audioManager.loop("low-health-heartbeat", { volume: 0.4 });
  } else if (healthPercent >= 0.3 && audioManager.isPlaying("heartbeat")) {
    audioManager.stop("low-health-heartbeat");
  }
});
```

---

## ğŸ§ Audio Ducking Implementation

**Ducking** = Lower music volume when speech starts, restore when speech ends

```typescript
class AudioManager {
  private currentMusic: Howl | null = null;
  private originalMusicVolume = 0.4;

  playMusic(trackName: string, options: { loop: boolean; volume: number }) {
    // Stop current music
    if (this.currentMusic) {
      this.currentMusic.fade(this.currentMusic.volume(), 0, 500); // 500ms fade out
      this.currentMusic.once("fade", () => this.currentMusic?.stop());
    }

    // Start new music
    this.originalMusicVolume = options.volume;
    this.currentMusic = new Howl({
      src: [`/sounds/${trackName}.mp3`],
      loop: options.loop,
      volume: 0,
      html5: true, // Streaming for large files
    });

    this.currentMusic.play();
    this.currentMusic.fade(0, options.volume, 1000); // 1s fade in
  }

  duck() {
    // Lower music to 20% for speech
    if (this.currentMusic) {
      this.currentMusic.fade(this.currentMusic.volume(), 0.2, 300);
    }
  }

  unduck() {
    // Restore original volume after speech
    if (this.currentMusic) {
      this.currentMusic.fade(
        this.currentMusic.volume(),
        this.originalMusicVolume,
        500
      );
    }
  }
}
```

---

## ğŸ“¢ Role Reveal Sequence (7 seconds)

**Timeline**:

```
T=0s:  Game starts
       â†’ Player hears role-reveal.mp3 (0.5s)

T=0.5s: TTS begins
        â†’ "You are the Vampire."

T=2s:   TTS continues
        â†’ "Your goal is to kill during bloodlust to gain points."

T=4s:   (If has target) TTS continues
        â†’ "Your target is Player number 3."

T=7s:   Dashboard countdown starts
        â†’ "3... 2... 1... GO!" (audible to all players via speakers)

T=10s:  Gameplay begins
```

**Implementation**:

```typescript
// Player View
socket.on("role:assigned", ({ role, description, targetNumber }) => {
  // Play intro sound
  audioManager.play("role-reveal", { volume: 0.7 });

  // Wait for intro sound to finish
  setTimeout(() => {
    // Speak role assignment
    let speech = `You are the ${role}. ${description}`;

    if (targetNumber) {
      speech += ` Your target is Player number ${targetNumber}.`;
    }

    audioManager.speak(speech);
  }, 500);
});

// Dashboard
socket.on("round:start", ({ roundNumber }) => {
  // Wait 7 seconds for role reveals to finish
  setTimeout(() => {
    audioManager.speak("3");
    setTimeout(() => audioManager.speak("2"), 1000);
    setTimeout(() => audioManager.speak("1"), 2000);
    setTimeout(() => audioManager.speak("GO!"), 3000);
  }, 7000);
});
```

---

## ğŸ”Š Audio File Organization

```
public/sounds/
â”œâ”€â”€ music/
â”‚   â”œâ”€â”€ lobby-music.mp3           # Calm waiting music
â”‚   â”œâ”€â”€ tension-medium.mp3        # Standard gameplay
â”‚   â”œâ”€â”€ tension-high.mp3          # 3 or fewer players
â”‚   â””â”€â”€ victory.mp3               # Round/game end
â”‚
â”œâ”€â”€ effects/
â”‚   â”œâ”€â”€ damage.mp3                # Taking damage (short thud)
â”‚   â”œâ”€â”€ death.mp3                 # Player elimination
â”‚   â”œâ”€â”€ low-health-heartbeat.mp3  # Looping heartbeat when <30% health
â”‚   â””â”€â”€ wolf-howl.mp3             # Halloween event (optional)
â”‚
â””â”€â”€ voice/
    â””â”€â”€ role-reveal.mp3           # Role assignment intro sound
```

**File Requirements**:

- Format: MP3 (best mobile compatibility)
- Bit rate: 128 kbps (balance quality/size)
- Music files: ~2-3 minutes each, loopable
- SFX files: < 2 seconds each
- Total size budget: < 15 MB for all audio

---

## ğŸ¼ Audio Preloading

**Problem**: Audio lag on first play (especially on mobile)

**Solution**: Preload all sounds during lobby phase

```typescript
// audioManager.ts
class AudioManager {
  private sounds: Map<string, Howl> = new Map();

  async preload(soundFiles: string[]) {
    const promises = soundFiles.map((file) => {
      return new Promise((resolve, reject) => {
        const sound = new Howl({
          src: [`/sounds/${file}.mp3`],
          preload: true,
          onload: () => {
            this.sounds.set(file, sound);
            resolve(true);
          },
          onloaderror: reject,
        });
      });
    });

    await Promise.all(promises);
  }

  play(soundName: string, options?: { volume?: number }) {
    const sound = this.sounds.get(soundName);
    if (!sound) {
      console.warn(`Sound '${soundName}' not preloaded`);
      return;
    }

    sound.volume(options?.volume ?? 0.5);
    sound.play();
  }
}

// In App.tsx or JoinView
useEffect(() => {
  audioManager.preload([
    "damage",
    "death",
    "low-health-heartbeat",
    "role-reveal",
    "lobby-music",
    "tension-medium",
    "tension-high",
    "victory",
  ]);
}, []);
```

---

## ğŸ“± Mobile Audio Gotchas

### iOS Audio Restrictions

1. **Autoplay Blocked**: Audio must be triggered by user gesture
   - **Solution**: First sound plays on user tap (e.g., "Join Game" button)
2. **Silent Mode**: Hardware switch may mute all audio

   - **No solution**: Inform players to unmute

3. **Background Audio**: Safari pauses audio when app backgrounded
   - **Solution**: Use Wake Lock + fullscreen to prevent backgrounding

### Android Audio Restrictions

1. **Autoplay Blocked** (Chrome 66+): Similar to iOS

   - **Solution**: Same as iOS

2. **Audio Context Limit**: Max 6 simultaneous Web Audio sources
   - **Solution**: Use Howler.js pooling to reuse sources

### Cross-Browser Audio Init

```typescript
// Unlock audio on first user interaction
let audioUnlocked = false;

function unlockAudio() {
  if (audioUnlocked) return;

  // Play and immediately stop a silent sound to unlock audio context
  const unlockSound = new Howl({
    src: [
      "data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=",
    ],
    volume: 0,
  });

  unlockSound.play();
  audioUnlocked = true;

  console.log("Audio context unlocked");
}

// Attach to first user interaction
document.addEventListener("touchstart", unlockAudio, { once: true });
document.addEventListener("click", unlockAudio, { once: true });
```

---

## ğŸ›ï¸ Audio Manager API

```typescript
interface AudioManagerAPI {
  // Music management
  playMusic(track: string, options: { loop: boolean; volume: number }): void;
  stopMusic(): void;
  fadeMusic(targetVolume: number, duration: number): void;

  // Sound effects
  play(soundName: string, options?: { volume?: number }): void;
  loop(soundName: string, options?: { volume?: number }): void;
  stop(soundName: string): void;
  isPlaying(soundName: string): boolean;

  // Text-to-speech
  speak(text: string): void;
  stopSpeaking(): void;
  isSpeaking(): boolean;

  // Audio ducking
  duck(): void;
  unduck(): void;

  // Lifecycle
  preload(soundFiles: string[]): Promise<void>;
  setMasterVolume(volume: number): void;
  mute(): void;
  unmute(): void;
}
```

---

## ğŸ”‡ Audio Settings (Future Enhancement)

Allow players to adjust audio levels:

```typescript
interface AudioSettings {
  masterVolume: number; // 0-1
  musicVolume: number; // 0-1
  sfxVolume: number; // 0-1
  ttsVolume: number; // 0-1
  ttsRate: number; // 0.5-2.0
  muteTTS: boolean;
  muteSFX: boolean;
  muteMusic: boolean;
}

// Store in localStorage
localStorage.setItem("audioSettings", JSON.stringify(settings));
```

---

This specification continues in **Part 3: UI Specifications** â†’
